--- 
title: "disk.frame - larger-than-RAM data manipulatoin"
author: "Dai ZJ"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "disk.frame is the R framework for manipulating larger-than-RAM data"
---

# The story of how `disk.frame` came to be
I was working at a one of Australia's largest banks and their shiny new SAS server was experiencing huge instability issues. As a result, we had to SAS on our laptop to perform huge amounts of data manipulation. A simple SQL query can take up wards of 20 minutes.

I had enough.

That's why I created `disk.frame` - a larger-than-RAM data manipulation framework for R.

<!--chapter:end:index.Rmd-->

# Introduction

## The story of how `disk.frame` came to be
I was working at a one of Australia's largest banks and their shiny new SAS server was experiencing huge instability issues. As a result, we had to SAS on our laptop to perform huge amounts of data manipulation. A simple SQL query can take up wards of 20 minutes.

I had enough.

That's why I created `disk.frame` - a larger-than-RAM data manipulation framework for R.

<!--chapter:end:01-intro.Rmd-->

---
title: "Testing"
author: "ZJ"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic Data Operations - nycflights13}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(disk.frame)
library(fst)
library(magrittr)
library(nycflights13)
library(dplyr)
library(data.table)

# you need to run this for multi-worker support
# limit to 2 cores if not running interactively; most likely on CRAN
if(interactive()) {
  setup_disk.frame()
} else {
  setup_disk.frame(2)
}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Quick Start - replicating dplyr's tutorial on nycflight13 

The [`disk.frame` package](https://github.com/xiaodaigh/disk.frame) aims to be the answer to the question: how do I manipulate structured tabular data that doesn't fit into Random Access Memory (RAM)? 

In a nutshell, `disk.frame` makes use of two simple ideas

1) split up a larger-than-RAM dataset into chunks and store each chunk in a separate file inside a folder and 
2) provide a convenient API to manipulate these chunks

`disk.frame` performs a similar role to distributed systems such as Apache Spark, Python's Dask, and Julia's JuliaDB.jl for *medium data* which are datasets that are too large for RAM but not quite large enough to qualify as *big data*.

In this tutorial, we introduce `disk.frame`, address some common questions, and replicate the [sparklyr data manipulation tutorial](https://spark.rstudio.com/dplyr/) using `disk.frame` constructs.

## Installation
Simply run

```r
install.packages("disk.frame") # when CRAN ready
```
or

```r
devtools::install_github("xiaodaigh/disk.frame")
```

## Set-up `disk.frame`
`disk.frame` works best if it can process multiple data chunks in parallel. The best way to set-up `disk.frame` so that each CPU core runs a background worker is by using

```r
setup_disk.frame()
```

The `setup_disk.frame()` sets up background workers equal to the number of CPU cores; please note that, by default, hyper-threaded cores are counted as one not two.

Alternatively, one may specify the number of workers using `setup_disk.frame(workers = n)`.

## Basic Data Operations with `disk.frame`

The `disk.frame` package provides convenient functions to convert `data.frame`s and CSVs to `disk.frame`s.

### Creating a `disk.frame` from `data.frame`
We convert a `data.frame` to `disk.frame` using the `as.data.frame` function.

```{r asdiskframe, cache=TRUE}
library(nycflights13)
library(dplyr)
library(disk.frame)
library(data.table)

# convert the flights data to a disk.frame and store the disk.frame in the folder
# "tmp_flights" and overwrite any content if needed
flights.df <- as.disk.frame(
  flights, 
  outdir = file.path(tempdir(), "tmp_flights.df"),
  overwrite = TRUE)
flights.df
```
You should now see a folder called `tmp_flights` with some files in it, namely `1.fst`, `2.fst`.... where each `fst` files is one chunk of the `disk.frame`.


### Creating a `disk.frame` from CSV
```{r}
library(nycflights13)
# write a csv
csv_path = file.path(tempdir(), "tmp_flights.csv")
data.table::fwrite(flights, csv_path)

# load the csv into a disk.frame
df_path = file.path(tempdir(), "tmp_flights.df")
flights.df <- csv_to_disk.frame(
  csv_path, 
  outdir = df_path,
  overwrite = T)
  
flights.df
```

If the CSV is too large to read in, then we can also use the `in_chunk_size` option to control how many rows to read in at once. For example to read in the data 100,000 rows at a time.

```{r}
library(nycflights13)
library(disk.frame)

# write a csv
csv_path = file.path(tempdir(), "tmp_flights.csv")

data.table::fwrite(flights, csv_path)

df_path = file.path(tempdir(), "tmp_flights.df")

flights.df <- csv_to_disk.frame(
  csv_path, 
  outdir = df_path, 
  in_chunk_size = 100000)
  
flights.df
```

`disk.frame` also has a function `zip_to_disk.frame` that can convert every CSV in a zip file to `disk.frame`s.

### Simple `dplyr` verbs and lazy evaluation
```{r dfselect, dependson='asdiskframe', cache=TRUE}
flights.df1 <- select(flights.df, year:day, arr_delay, dep_delay)
flights.df1
```

```{r dependson='dfselect'}
class(flights.df1)
```

The class of `flights.df1` is also a `disk.frame` after the   `dplyr::select` transformation. Also, `disk.frame` operations are by default (and where possible) **lazy**, meaning it doesn't perform the operations right away. Instead, it waits until you call `collect`. Exceptions to this rule are the `*_join` operations which evaluated *eagerly* under certain conditions see **Joins for disk.frame in-depth** for details.

For lazily constructed `disk.frame`s (e.g. `flights.df1`). The function `collect` can be used to bring the results from disk into R, e.g.
```{r, dependson='dfselect'}
collect(flights.df1) %>% head
```

Of course, for larger-than-RAM datasets, one wouldn't call `collect` on the whole `disk.frame` (because why would you need `disk.frame` otherwise). More likely, one would call `collect` on a `filter`ed dataset or one summarized with `group_by`.

Some examples of other dplyr verbs applied:

```{r, dependson='asdiskframe'}
filter(flights.df, dep_delay > 1000) %>% collect %>% head
```

```{r, dependson='asdiskframe'}
mutate(flights.df, speed = distance / air_time * 60) %>% collect %>% head
```

### Examples of NOT fully supported `dplyr` verbs

The `arrange` function arranges (sort) each chunk but not the whole dataset. So use with caution. Similarly `summarise` creates summary variables within each chunk and hence also needs to be used with caution. In the Group By section, we demonstrate how to use `summarise` in the `disk.frame` context correctly with `hard_group_by`s.

```{r, dependson='asdiskframe'}
# this only sorts within each chunk
arrange(flights.df, dplyr::desc(dep_delay)) %>% collect %>% head
```


```{r, dependson='asdiskframe'}
summarize(flights.df, mean_dep_delay = mean(dep_delay, na.rm =T)) %>% collect
```

### Piping

One can chain `dplyr` verbs together like with a `data.frame`

```{r, dependson='asdiskframe'}
c4 <- flights %>%
  filter(month == 5, day == 17, carrier %in% c('UA', 'WN', 'AA', 'DL')) %>%
  select(carrier, dep_delay, air_time, distance) %>%
  mutate(air_time_hours = air_time / 60) %>%
  collect %>%
  arrange(carrier)# arrange should occur after `collect`

c4  %>% head
```

### List of supported `dplyr` verbs

```r
select
rename
filter
arrange # within each chunk
group_by # within each chunk
summarise/summarize # within each chunk
mutate
transmute
left_join
inner_join
full_join # careful. Performance!
semi_join
anit_join
```
## Sharding and distribution of chunks

Like other distributed data manipulation frameworks `disk.frame` utilizes the *sharding* concept to distribute the data into chunks. For example "to shard by `cust_id`" means that all rows with the same `cust_id` will be stored in the same chunk. This enables `group_by` by `cust_id` to produce the same results as non-chunked data.

The `by` variables that were used to shard the dataset are called the `shardkey`s. The *sharding* is performed by computing a deterministic hash on the shard keys (the `by` variables) for each row. The hash function produces an integer between `1` and `n`, where `n` is the number of chunks. 

## Grouping

The `disk.frame` implements the `group_by` operation with a significant caveat. In the `disk.frame` framework, group-by happen WITHIN each chunk and not ACROSS chunks. To achieve group by across chunk we need to put **all rows with the same group keys into the same file chunk**; this can be achieved with `hard_group_by`. However, the `hard_group_by` operation can be **VERY TIME CONSUMING** computationally and should be **avoided** if possible.

The `hard_group_by` operation is best illustrated with an example, suppose a `disk.frame` has three chunks
```
# chunk1 = 1.fst
#  id n
#1  a 1
#2  a 2
#3  b 3
#4  d 4

# chunk2 = 2.fst
#  id n
#1  a 4
#2  a 5
#3  b 6
#4  d 7

# chunk3 = 3.fst
#  id n
#1  a 4
#2  b 5
#3  c 6
```
and notice that the `id` column contains 3 distinct values `"a"`,`"b"`, and `"c"`. To perform `hard_group_by(df, by = id)` MAY give you the following `disk.frame` where all the `id`s with the same values end up in the same chunks. 

```
# chunk1 = 1.fst
#  id n
#1  b 3
#2  b 6

# chunk2 = 2.fst
#  id n
#1  c 6
#2  d 4
#3  d 7

# chunk3 = 3.fst
#  id n
#1  a 1
#2  a 2
#3  a 4
#4  a 5
#5  a 4
```

Also, notice that there is no guaranteed order for the distribution of the `id`s to the chunks. The order is random, but each chunk is likely to have a similar number of rows, provided that `id` does not follow a skewed distribution i.e. where a few distinct values make up the majority of the rows.

Typically, `group_by` is performed WITHIN each chunk. This is not an issue if the chunks have already been sharded on the `by` variables beforehand; however, if this is not the case then one may need a second stage aggregation to obtain the correct result, see *Two-stage group by*.

By forcing the user to choose `group_by` (within each chunk) and `hard_group_by` (across all chunks), this ensures that the user is conscious of the choice they are making. In `sparklyr` the equivalent of a `hard_group_by` is performed, which we should avoid, where possible, as it is time-consuming and expensive. Hence, `disk.frame` has chosen to explain the theory and allow the user to make a conscious choice when performing `(hard_)group_by`.

```{r, dependson='asdiskframe'}
flights.df %>%
  hard_group_by(carrier) %>% # notice that hard_group_by needs to be set
  summarize(count = n(), mean_dep_delay = mean(dep_delay, na.rm=T)) %>%  # mean follows normal R rules
  collect %>% 
  arrange(carrier)
```

### Two-stage group by
For most group-by tasks, the user can achieve the desired result WITHOUT using `hard = TRUE` by performing the group by in two stages. For example, suppose you aim to count the number of rows group by `carrier`, you can set `hard = F` to find the count within each chunk and then use a second group-by to summaries each chunk's results into the desired result. For example,

```{r, dependson='asdiskframe'}
flights.df %>%
  group_by(carrier) %>% # `group_by` aggregates within each chunk
  summarize(count = n()) %>%  # mean follows normal R rules
  collect %>%  # collect each individul chunks results and row-bind into a data.table
  group_by(carrier) %>% 
  summarize(count = sum(count)) %>% 
  arrange(carrier)
```

Because this two-stage approach avoids the expensive `hard group_by` operation, it is often significantly faster. However, it can be tedious to write; and this is a con of the `disk.frame` chunking mechanism.

*Note*: this two-stage approach is similar to a map-reduce operation.


## Restrict input columns for faster processing

One can restrict which input columns to load into memory for each chunk; this can significantly increase the speed of data processing. To restrict the input columns, use the `srckeep` function which only accepts column names as a string vector.

```{r, dependson='asdiskframe'}
flights.df %>%
  srckeep(c("carrier","dep_delay")) %>%
  hard_group_by(carrier) %>% 
  summarize(count = n(), mean_dep_delay = mean(dep_delay, na.rm=T)) %>%  # mean follows normal R rules
  collect
```

Input column restriction is one of the most critical efficiencies provided by `disk.frame`. Because the underlying format allows random access to columns (i.e. retrieve only the columns used for processing), hence one can drastically reduce the amount of data loaded into RAM for processing by keeping only those columns that are directly used to produce the results.

## Joins

`disk.frame` supports many dplyr joins including:

```r
left_join
inner_join
semi_join
inner_join
full_join # requires hard_group_by on both left and right
```
In all cases, the left dataset (`x`) must be a `disk.frame`, and the right dataset (`y`) can be either a `disk.frame` or a `data.frame`. If the right dataset is a `disk.frame` and the `shardkey`s are different between the two `disk.frame`s then two expensive `hard` `group_by` operations are performed *eagerly*, one on the left `disk.frame` and one on the right `disk.frame` to perform the joins correctly. 

However, if the right dataset is a `data.frame` then `hard_group_by`s are only performed in the case of `full_join`.

Note `disk.frame` does not support `right_join` the user should use `left_join` instead.

The below joins are performed *lazily* because `airlines.dt` is a `data.table` not a `disk.frame`:

```{r airlines_dt, dependson='asdiskframe', cache=TRUE}
# make airlines a data.table
airlines.dt <- data.table(airlines)
# flights %>% left_join(airlines, by = "carrier") #
flights.df %>% 
  left_join(airlines.dt, by ="carrier") %>% 
  collect %>% 
  head
```

```{r, dependson='airlines_dt'}
flights.df %>% 
  left_join(airlines.dt, by = c("carrier", "carrier")) %>% 
  collect %>% 
  tail
```

## Window functions and arbitrary functions

`disk.frame` supports all `data.frame` operations, unlike Spark which can only perform those operations that Spark has implemented. Hence windowing functions like `rank` are supported out of the box.

```{r, dependson='asdiskframe'}
# Find the most and least delayed flight each day
bestworst <- flights.df %>%
   srckeep(c("year","month","day", "dep_delay")) %>%
   group_by(year, month, day) %>%
   select(dep_delay) %>%
   filter(dep_delay == min(dep_delay, na.rm = T) || dep_delay == max(dep_delay, na.rm = T)) %>%
   collect
   

bestworst %>% head
```

```{r, dependson='asdiskframe'}
# Rank each flight within a daily
ranked <- flights.df %>%
  srckeep(c("year","month","day", "dep_delay")) %>%
  group_by(year, month, day) %>%
  select(dep_delay) %>%
  mutate(rank = rank(desc(dep_delay))) %>%
  collect

ranked %>% head
```


## Arbitrary by-chunk processing
One can apply arbitrary transformations to each chunk of the `disk.frame` by using the `delayed` function which evaluates lazily or the `map.disk.frame(lazy = F)` function which evaluates eagerly. For example to return the number of rows in each chunk

```{r, dependson='asdiskframe'}
flights.df1 <- delayed(flights.df, ~nrow(.x))
collect_list(flights.df1) %>% head # returns number of rows for each data.frame in a list
```
and to do the same with `map.disk.frame`

```{r, dependson='asdiskframe'}
map(flights.df, ~nrow(.x), lazy = F) %>% head
```
The `map` function can also output the results to another disk.frame folder, e.g.

```{r, dependson='asdiskframe'}
# return the first 10 rows of each chunk
flights.df2 <- map(flights.df, ~.x[1:10,], lazy = F, outdir = file.path(tempdir(), "tmp2"), overwrite = T)

flights.df2 %>% head
```

Notice `disk.frame` supports the `purrr` syntax for defining a function using `~`.

## Sampling

In the `disk.frame` framework, sampling a proportion of rows within each chunk can be performed using `sample_frac`. 

```{r, dependson='asdiskframe'}
flights.df %>% sample_frac(0.01) %>% collect %>% head
```

## Writing Data

One can output a `disk.frame` by using the `write_disk.frame` function. E.g.

```r
write_disk.frame(flights.df, outdir="out")
```
this will output a disk.frame to the folder "out"

```{r cleanup}
fs::dir_delete(file.path(tempdir(), "tmp_flights.df"))
fs::dir_delete(file.path(tempdir(), "tmp2"))
fs::file_delete(file.path(tempdir(), "tmp_flights.csv"))
```

<!--chapter:end:02-intro-disk-frame.Rmd-->

---
title: "Concepts for disk.frame"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Concepts for disk.frame}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

There are a number of concepts and terminologies that are useful to understand in order to use `disk.frame` effectively.

## What is a `disk.frame` and what are chunks?
A `disk.frame` is nothing more a folder and in that folder there should be [`fst`](https://www.fstpackage.org/) files named "1.fst", "2.fst", "3.fst" etc. Each of the ".fst" file is called a _chunk_.

## Workers and parallelism
Parallelism in `disk.frame` is achieved using the [`future` package](https://cran.r-project.org/package=future). When performing many tasks, `disk.frame` uses multiple workers, where each _worker_ is an R session, to perform the tasks in parallel. For example, suppose we wish to compute the number of rows for each chunk, we can clearly perform this simultaneously in parallel. The code to do that is

```r
# use only one column is fastest
df[,.N, keep = "first_col"]
```
Say there are `n` chunks in `df`, and there are `m` workers. Then the first `m` chunks will run `chunk[,.N]` simultaneously.

To see how many workers are at work, use
```r
# see how many workers are available for work
future::nbrOfWorkers()
```



<!--chapter:end:03-concepts.Rmd-->

---
title: "Ingesting Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ingesting-data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Let's set-up `disk.frame`
```r
library(disk.frame)

# set up multiple
setup_disk.frame()
```

One of the most important tasks to perform before using the `disk.frame` package is to make some `disk.frame`s! There are a few functions to help you do that.

## Convert a `data.frame` to `disk.frame`
Firstly there is `as.disk.frame()` which allows you to make a `disk.frame` from a `data.frame`, e.g.

```r
flights.df = as.disk.frame(nycflights13::flights)
```

will convert the `nycflights13::flights` `data.frame` to a `disk.frame` somewhere in `tempdir()`. To find out the location of the `disk.frame` use:

```r
attr(flights.df, "path")
```

You can also specify a location to output the `disk.frame` to using `outdir`

```r
flights.df = as.disk.frame(nycflights13::flights, outdir = "some/path.df")
```

it is recommended that you use `.df` as the extension for a `disk.frame`, however this is not an enforced requirement.

However, one of the reasons for `disk.frame` to exist is to handle larger-than-RAM files, hence `as.disk.frame` is not all that useful because it can only convert data that can fit into RAM. `disk.frame` comes with a couple more ways to create `disk.frame`.

## Creating `disk.frame` from CSVs
The function `csv_to_disk.frame` can convert CSV files to `disk.frame`. The most basic usage is

```r
some.df = csv_to_disk.frame("some/path.csv", outdir = "some.df")
```

this will convert the CSV file `"some/path.csv"` to a `disk.frame`. 

## Multiple CSV files

However, sometimes we have multiple CSV files that you want to read in and row-bind into one large `disk.frame`. You can do so by supplying a vector of file paths e.g. from the result of `list.files`

```r
some.df = csv_to_disk.frame(c("some/path/file1.csv", "some/path/file2.csv"))

# or
some.df = csv_to_disk.frame(list.files("some/path"))
```

## Inputing CSV files chunk-wise
The `csv_to_disk.frame(path, ...)` function reads the file located at `path` in full into RAM but sometimes the CSV file may be too large to read in one go, as that would require loading the whole file into RAM. In that case, you can read the files chunk-by-chunk by using the `in_chunk_size` argument which controls how many rows you read in per chunk

```r
# to read in 1 million (=1e6) rows per chunk
csv_to_disk.frame(path, in_chunk_size = 1e6)
```

## Sharding
One of the most important aspects of `disk.frame` is sharding. One can shard a `disk.frame` at read time by using the `shardby`

```r
csv_to_disk.frame(path, shardby = "id")
```

In the above case, all rows with the same `id` values will end up in the same chunk.


## Just-in-time transformation
Sometimes, one may wish to perform some transformation on the CSV before writing out to disk. One can use the `inmapfn` argument to do that. The `inmapfn` name comes from INput MAPping FuNction. The general usage pattern is as follows:

```r
csv_to_disk.frame(file.path(tempdir(), "df.csv"), inmapfn = function(chunk) {
  some_transformation(chunk)
})
```

As a contrived example, suppose you wish to convert a string into date at read time:

```r
df = data.frame(date_str = c("2019-01-02", "2019-01-02"))

# write the data.frame 
write.csv(df, file.path(tempdir(), "df.csv"))


# this would show that date_str is a string
str(collect(csv_to_disk.frame(file.path(tempdir(), "df.csv")))$date_str)
## chr [1:2] "2019-01-02" "2019-01-02"

# this would show that date_str is a string
df = csv_to_disk.frame(file.path(tempdir(), "df.csv"), inmapfn = function(chunk) {
  # convert to date_str to date format and store as "date"
  chunk[, date := as.Date(date_str, "%Y-%m-%d")]
  chunk[, date_str:=NULL]
})

str(collect(df)$date)
## Date[1:2], format: "2019-01-02" "2019-01-02"
```

## Reading CSVs from zip files
Often, CSV comes zipped in a zip files. You can use the `zip_to_disk.frame` to convert all CSVs within a zip file

```r
zip_to_disk.frame(path_to_zip_file)
```

The arguments for `zip_to_disk.frame` are the same as `csv_to_disk.frame`'s.


## Using `add_chunk`

What if the method of converting to a `disk.frame` isn't implemented in `disk.frame` yet? One can use some lower level constructs provided by `disk.frame` to create `disk.frame`s. For example, the `add_chunk` function can be used to add more chunks to a `disk.frame`, e.g.

```r
a.df = disk.frame() # create an empty disk.frame
add_chunk(a.df, cars) # adds cars as chunk 1
add_chunk(a.df, cars) # adds cars as chunk 2
```

Another example of using `add_chunk` is via `readr`'s chunked read functions to create a delimited file reader

```r
delimited_to_disk.frame <- function(file, outdir, ...) {
  res.df = disk.frame(outdir, ...)
  readr::read_delim_chunked(file, callback = function(chunk) {
    add_chunk(res.df, chunk)
  }, ...)
  
  res.df
}

delimited_to_disk.frame(path, outdir = "some.df")
```

The above code uses `readr`'s `read_delim_chunked` function to read `file` and call `add_chunk`. The problem with this approach is that is it sequential in nature and hence is not able to take advantage of parallelism.

## Exploiting the structure of a disk.frame

Of course, a `disk.frame` is just a folder with many `fst` files named as `1.fst`, `2.fst` etc. So one can simply create these `fst` files and ensure they have the same variable names and put them in a folder.

<!--chapter:end:04-ingesting-data.Rmd-->

---
title: "Using data.table syntax with disk.frame"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{data-table-syntax}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## `disk.frame` supports `data.table` syntax


```{r setup_data_table, cache=TRUE}
library(disk.frame)

# set-up disk.frame to use multiple workers
if(interactive()) {
  setup_disk.frame()
} else {
  setup_disk.frame(2)
}


library(nycflights13)

# create a disk.frame
flights.df = as.disk.frame(nycflights13::flights, outdir = file.path(tempdir(),"flights13"), overwrite = TRUE)
```

In the following example, I will use the `.N` from the `data.table` package to count the unique combinations `year` and `month` within each chunk.

```{r ok, dependson='setup_data_table'}
library(disk.frame)

flights.df = disk.frame(file.path(tempdir(),"flights13"))

names(flights.df)

flights.df[,.N, .(year, month), keep = c("year", "month")]
```

All `data.table` syntax are supported. However, `disk.frame` adds the ability to load only those columns required for the analysis using the `keep =` option. In the above analysis, only the `year` and `month` variables are required and hence `keep = c("year", "month")` was used. 

Alternatively, we can use the `srckeep` function to achieve the same, e.g.

```r
srckeep(flights.df, c("year", "month"))[,.N, .(year, month)]
```

### External variables are captured

`disk.frame` sends the computaion to background workers which are essentially distinct and separate R sessions. Typically, the variables that you have available in your current R session aren't visible in the other R sessions, but `disk.frame` uses the `future` package's variable detection abilities to figure out which variables are in use and then send them to the background workers so they have access to the variables as well. E.g.

```{r var_detect, dependson='setup_data_table'}
y = 42 
some_fn <- function(x) x


flights.df[,some_fn(y)]
```

In the above example, neither `some_fn` nor `y` are defined in the background workers' environments, but `disk.frame` still manages to evaluate this code `flights.df[,some_fn(y)]`.

```{r clean_up, include=FALSE}
fs::dir_delete(file.path(tempdir(),"flights13"))
```

<!--chapter:end:05-data-table-syntax.Rmd-->

