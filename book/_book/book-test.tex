\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={disk.frame - larger-than-RAM data manipulatoin},
            pdfauthor={Yihui Xie},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{natbib}
\bibliographystyle{apalike}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\providecommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{disk.frame - larger-than-RAM data manipulatoin}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{Yihui Xie}
    \preauthor{\centering\large\emph}
  \postauthor{\par}
      \predate{\centering\large\emph}
  \postdate{\par}
    \date{2019-08-17}

\usepackage{booktabs}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{the-story-of-how-disk.frame-came-to-be}{%
\chapter{\texorpdfstring{The story of how \texttt{disk.frame} came to be}{The story of how disk.frame came to be}}\label{the-story-of-how-disk.frame-came-to-be}}

I was working at a one of Australia's largest banks and their shiny new SAS server was experiencing huge instability issues. As a result, we had to SAS on our laptop to perform huge amounts of data manipulation. A simple SQL query can take up wards of 20 minutes.

I had enough.

That's why I created \texttt{disk.frame} - a larger-than-RAM data manipulation framework for R.

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

\hypertarget{the-story-of-how-disk.frame-came-to-be-1}{%
\section{\texorpdfstring{The story of how \texttt{disk.frame} came to be}{The story of how disk.frame came to be}}\label{the-story-of-how-disk.frame-came-to-be-1}}

I was working at a one of Australia's largest banks and their shiny new SAS server was experiencing huge instability issues. As a result, we had to SAS on our laptop to perform huge amounts of data manipulation. A simple SQL query can take up wards of 20 minutes.

I had enough.

That's why I created \texttt{disk.frame} - a larger-than-RAM data manipulation framework for R.

\hypertarget{quick-start---replicating-dplyrs-tutorial-on-nycflight13}{%
\chapter{Quick Start - replicating dplyr's tutorial on nycflight13}\label{quick-start---replicating-dplyrs-tutorial-on-nycflight13}}

The \href{https://github.com/xiaodaigh/disk.frame}{\texttt{disk.frame} package} aims to be the answer to the question: how do I manipulate structured tabular data that doesn't fit into Random Access Memory (RAM)?

In a nutshell, \texttt{disk.frame} makes use of two simple ideas

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  split up a larger-than-RAM dataset into chunks and store each chunk in a separate file inside a folder and
\item
  provide a convenient API to manipulate these chunks
\end{enumerate}

\texttt{disk.frame} performs a similar role to distributed systems such as Apache Spark, Python's Dask, and Julia's JuliaDB.jl for \emph{medium data} which are datasets that are too large for RAM but not quite large enough to qualify as \emph{big data}.

In this tutorial, we introduce \texttt{disk.frame}, address some common questions, and replicate the \href{https://spark.rstudio.com/dplyr/}{sparklyr data manipulation tutorial} using \texttt{disk.frame} constructs.

\hypertarget{installation}{%
\section{Installation}\label{installation}}

Simply run

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"disk.frame"}\NormalTok{) }\CommentTok{# when CRAN ready}
\end{Highlighting}
\end{Shaded}

or

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"xiaodaigh/disk.frame"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{set-up-disk.frame}{%
\section{\texorpdfstring{Set-up \texttt{disk.frame}}{Set-up disk.frame}}\label{set-up-disk.frame}}

\texttt{disk.frame} works best if it can process multiple data chunks in parallel. The best way to set-up \texttt{disk.frame} so that each CPU core runs a background worker is by using

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setup_disk.frame}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The \texttt{setup\_disk.frame()} sets up background workers equal to the number of CPU cores; please note that, by default, hyper-threaded cores are counted as one not two.

Alternatively, one may specify the number of workers using \texttt{setup\_disk.frame(workers\ =\ n)}.

\hypertarget{basic-data-operations-with-disk.frame}{%
\section{\texorpdfstring{Basic Data Operations with \texttt{disk.frame}}{Basic Data Operations with disk.frame}}\label{basic-data-operations-with-disk.frame}}

The \texttt{disk.frame} package provides convenient functions to convert \texttt{data.frame}s and CSVs to \texttt{disk.frame}s.

\hypertarget{creating-a-disk.frame-from-data.frame}{%
\subsection{\texorpdfstring{Creating a \texttt{disk.frame} from \texttt{data.frame}}{Creating a disk.frame from data.frame}}\label{creating-a-disk.frame-from-data.frame}}

We convert a \texttt{data.frame} to \texttt{disk.frame} using the \texttt{as.data.frame} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(nycflights13)}
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{library}\NormalTok{(disk.frame)}
\KeywordTok{library}\NormalTok{(data.table)}

\CommentTok{# convert the flights data to a disk.frame and store the disk.frame in the folder}
\CommentTok{# "tmp_flights" and overwrite any content if needed}
\NormalTok{flights.df <-}\StringTok{ }\KeywordTok{as.disk.frame}\NormalTok{(}
\NormalTok{  flights, }
  \DataTypeTok{outdir =} \KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.df"}\NormalTok{),}
  \DataTypeTok{overwrite =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> Warning in expand_(path, Sys.getenv("R_FS_HOME") != "" || is_windows()):}
\CommentTok{#> '.Random.seed' is not an integer vector but of type 'NULL', so ignored}
\NormalTok{flights.df}
\CommentTok{#> path: "C:\textbackslash{}Users\textbackslash{}RTX2080\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Temp\textbackslash{}RtmpAVR4h1/tmp_flights.df"}
\CommentTok{#> nchunks: 6}
\CommentTok{#> nrow: 336776}
\CommentTok{#> ncol: 19}
\end{Highlighting}
\end{Shaded}

You should now see a folder called \texttt{tmp\_flights} with some files in it, namely \texttt{1.fst}, \texttt{2.fst}\ldots. where each \texttt{fst} files is one chunk of the \texttt{disk.frame}.

\hypertarget{creating-a-disk.frame-from-csv}{%
\subsection{\texorpdfstring{Creating a \texttt{disk.frame} from CSV}{Creating a disk.frame from CSV}}\label{creating-a-disk.frame-from-csv}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(nycflights13)}
\CommentTok{# write a csv}
\NormalTok{csv_path =}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.csv"}\NormalTok{)}
\NormalTok{data.table}\OperatorTok{::}\KeywordTok{fwrite}\NormalTok{(flights, csv_path)}

\CommentTok{# load the csv into a disk.frame}
\NormalTok{df_path =}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.df"}\NormalTok{)}
\NormalTok{flights.df <-}\StringTok{ }\KeywordTok{csv_to_disk.frame}\NormalTok{(}
\NormalTok{  csv_path, }
  \DataTypeTok{outdir =}\NormalTok{ df_path,}
  \DataTypeTok{overwrite =}\NormalTok{ T)}
  
\NormalTok{flights.df}
\CommentTok{#> path: "C:\textbackslash{}Users\textbackslash{}RTX2080\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Temp\textbackslash{}RtmpAVR4h1/tmp_flights.df"}
\CommentTok{#> nchunks: 6}
\CommentTok{#> nrow: 336776}
\CommentTok{#> ncol: 19}
\end{Highlighting}
\end{Shaded}

If the CSV is too large to read in, then we can also use the \texttt{in\_chunk\_size} option to control how many rows to read in at once. For example to read in the data 100,000 rows at a time.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(nycflights13)}
\KeywordTok{library}\NormalTok{(disk.frame)}

\CommentTok{# write a csv}
\NormalTok{csv_path =}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.csv"}\NormalTok{)}

\NormalTok{data.table}\OperatorTok{::}\KeywordTok{fwrite}\NormalTok{(flights, csv_path)}

\NormalTok{df_path =}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.df"}\NormalTok{)}

\NormalTok{flights.df <-}\StringTok{ }\KeywordTok{csv_to_disk.frame}\NormalTok{(}
\NormalTok{  csv_path, }
  \DataTypeTok{outdir =}\NormalTok{ df_path, }
  \DataTypeTok{in_chunk_size =} \DecValTok{100000}\NormalTok{)}
\CommentTok{#> read 336776 rows from C:\textbackslash{}Users\textbackslash{}RTX2080\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Temp\textbackslash{}RtmpAVR4h1/tmp_flights.csv}
  
\NormalTok{flights.df}
\CommentTok{#> path: "C:\textbackslash{}Users\textbackslash{}RTX2080\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Temp\textbackslash{}RtmpAVR4h1/tmp_flights.df"}
\CommentTok{#> nchunks: 4}
\CommentTok{#> nrow: 336776}
\CommentTok{#> ncol: 19}
\end{Highlighting}
\end{Shaded}

\texttt{disk.frame} also has a function \texttt{zip\_to\_disk.frame} that can convert every CSV in a zip file to \texttt{disk.frame}s.

\hypertarget{simple-dplyr-verbs-and-lazy-evaluation}{%
\subsection{\texorpdfstring{Simple \texttt{dplyr} verbs and lazy evaluation}{Simple dplyr verbs and lazy evaluation}}\label{simple-dplyr-verbs-and-lazy-evaluation}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df1 <-}\StringTok{ }\KeywordTok{select}\NormalTok{(flights.df, year}\OperatorTok{:}\NormalTok{day, arr_delay, dep_delay)}
\NormalTok{flights.df1}
\CommentTok{#> path: "C:\textbackslash{}Users\textbackslash{}RTX2080\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Temp\textbackslash{}RtmpAVR4h1/tmp_flights.df"}
\CommentTok{#> nchunks: 4}
\CommentTok{#> nrow: 336776}
\CommentTok{#> ncol: 19}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(flights.df1)}
\CommentTok{#> [1] "disk.frame"        "disk.frame.folder"}
\end{Highlighting}
\end{Shaded}

The class of \texttt{flights.df1} is also a \texttt{disk.frame} after the \texttt{dplyr::select} transformation. Also, \texttt{disk.frame} operations are by default (and where possible) \textbf{lazy}, meaning it doesn't perform the operations right away. Instead, it waits until you call \texttt{collect}. Exceptions to this rule are the \texttt{*\_join} operations which evaluated \emph{eagerly} under certain conditions see \textbf{Joins for disk.frame in-depth} for details.

For lazily constructed \texttt{disk.frame}s (e.g.~\texttt{flights.df1}). The function \texttt{collect} can be used to bring the results from disk into R, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{collect}\NormalTok{(flights.df1) }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#>    year month day arr_delay dep_delay}
\CommentTok{#> 1: 2013     1   1        11         2}
\CommentTok{#> 2: 2013     1   1        20         4}
\CommentTok{#> 3: 2013     1   1        33         2}
\CommentTok{#> 4: 2013     1   1       -18        -1}
\CommentTok{#> 5: 2013     1   1       -25        -6}
\CommentTok{#> 6: 2013     1   1        12        -4}
\end{Highlighting}
\end{Shaded}

Of course, for larger-than-RAM datasets, one wouldn't call \texttt{collect} on the whole \texttt{disk.frame} (because why would you need \texttt{disk.frame} otherwise). More likely, one would call \texttt{collect} on a \texttt{filter}ed dataset or one summarized with \texttt{group\_by}.

Some examples of other dplyr verbs applied:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{filter}\NormalTok{(flights.df, dep_delay }\OperatorTok{>}\StringTok{ }\DecValTok{1000}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#>   year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time}
\CommentTok{#> 1 2013     1   9      641            900      1301     1242           1530}
\CommentTok{#> 2 2013     1  10     1121           1635      1126     1239           1810}
\CommentTok{#> 3 2013     6  15     1432           1935      1137     1607           2120}
\CommentTok{#> 4 2013     7  22      845           1600      1005     1044           1815}
\CommentTok{#> 5 2013     9  20     1139           1845      1014     1457           2210}
\CommentTok{#>   arr_delay carrier flight tailnum origin dest air_time distance hour}
\CommentTok{#> 1      1272      HA     51  N384HA    JFK  HNL      640     4983    9}
\CommentTok{#> 2      1109      MQ   3695  N517MQ    EWR  ORD      111      719   16}
\CommentTok{#> 3      1127      MQ   3535  N504MQ    JFK  CMH       74      483   19}
\CommentTok{#> 4       989      MQ   3075  N665MQ    JFK  CVG       96      589   16}
\CommentTok{#> 5      1007      AA    177  N338AA    JFK  SFO      354     2586   18}
\CommentTok{#>   minute            time_hour}
\CommentTok{#> 1      0 2013-01-09T14:00:00Z}
\CommentTok{#> 2     35 2013-01-10T21:00:00Z}
\CommentTok{#> 3     35 2013-06-15T23:00:00Z}
\CommentTok{#> 4      0 2013-07-22T20:00:00Z}
\CommentTok{#> 5     45 2013-09-20T22:00:00Z}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mutate}\NormalTok{(flights.df, }\DataTypeTok{speed =}\NormalTok{ distance }\OperatorTok{/}\StringTok{ }\NormalTok{air_time }\OperatorTok{*}\StringTok{ }\DecValTok{60}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#>   year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time}
\CommentTok{#> 1 2013     1   1      517            515         2      830            819}
\CommentTok{#> 2 2013     1   1      533            529         4      850            830}
\CommentTok{#> 3 2013     1   1      542            540         2      923            850}
\CommentTok{#> 4 2013     1   1      544            545        -1     1004           1022}
\CommentTok{#> 5 2013     1   1      554            600        -6      812            837}
\CommentTok{#> 6 2013     1   1      554            558        -4      740            728}
\CommentTok{#>   arr_delay carrier flight tailnum origin dest air_time distance hour}
\CommentTok{#> 1        11      UA   1545  N14228    EWR  IAH      227     1400    5}
\CommentTok{#> 2        20      UA   1714  N24211    LGA  IAH      227     1416    5}
\CommentTok{#> 3        33      AA   1141  N619AA    JFK  MIA      160     1089    5}
\CommentTok{#> 4       -18      B6    725  N804JB    JFK  BQN      183     1576    5}
\CommentTok{#> 5       -25      DL    461  N668DN    LGA  ATL      116      762    6}
\CommentTok{#> 6        12      UA   1696  N39463    EWR  ORD      150      719    5}
\CommentTok{#>   minute            time_hour    speed}
\CommentTok{#> 1     15 2013-01-01T10:00:00Z 370.0441}
\CommentTok{#> 2     29 2013-01-01T10:00:00Z 374.2731}
\CommentTok{#> 3     40 2013-01-01T10:00:00Z 408.3750}
\CommentTok{#> 4     45 2013-01-01T10:00:00Z 516.7213}
\CommentTok{#> 5      0 2013-01-01T11:00:00Z 394.1379}
\CommentTok{#> 6     58 2013-01-01T10:00:00Z 287.6000}
\end{Highlighting}
\end{Shaded}

\hypertarget{examples-of-not-fully-supported-dplyr-verbs}{%
\subsection{\texorpdfstring{Examples of NOT fully supported \texttt{dplyr} verbs}{Examples of NOT fully supported dplyr verbs}}\label{examples-of-not-fully-supported-dplyr-verbs}}

The \texttt{arrange} function arranges (sort) each chunk but not the whole dataset. So use with caution. Similarly \texttt{summarise} creates summary variables within each chunk and hence also needs to be used with caution. In the Group By section, we demonstrate how to use \texttt{summarise} in the \texttt{disk.frame} context correctly with \texttt{hard\_group\_by}s.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# this only sorts within each chunk}
\KeywordTok{arrange}\NormalTok{(flights.df, dplyr}\OperatorTok{::}\KeywordTok{desc}\NormalTok{(dep_delay)) }\OperatorTok{%>%}\StringTok{ }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#> Warning in arrange.disk.frame(flights.df, dplyr::desc(dep_delay)):}
\CommentTok{#> disk.frame only sorts (arange) WITHIN each chunk}
\CommentTok{#>   year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time}
\CommentTok{#> 1 2013     1   9      641            900      1301     1242           1530}
\CommentTok{#> 2 2013     1  10     1121           1635      1126     1239           1810}
\CommentTok{#> 3 2013    12   5      756           1700       896     1058           2020}
\CommentTok{#> 4 2013     1   1      848           1835       853     1001           1950}
\CommentTok{#> 5 2013    12  19      734           1725       849     1046           2039}
\CommentTok{#> 6 2013    12  17      705           1700       845     1026           2020}
\CommentTok{#>   arr_delay carrier flight tailnum origin dest air_time distance hour}
\CommentTok{#> 1      1272      HA     51  N384HA    JFK  HNL      640     4983    9}
\CommentTok{#> 2      1109      MQ   3695  N517MQ    EWR  ORD      111      719   16}
\CommentTok{#> 3       878      AA    172  N5DMAA    EWR  MIA      149     1085   17}
\CommentTok{#> 4       851      MQ   3944  N942MQ    JFK  BWI       41      184   18}
\CommentTok{#> 5       847      DL   1223  N375NC    EWR  SLC      290     1969   17}
\CommentTok{#> 6       846      AA    172  N5EMAA    EWR  MIA      145     1085   17}
\CommentTok{#>   minute            time_hour}
\CommentTok{#> 1      0 2013-01-09T14:00:00Z}
\CommentTok{#> 2     35 2013-01-10T21:00:00Z}
\CommentTok{#> 3      0 2013-12-05T22:00:00Z}
\CommentTok{#> 4     35 2013-01-01T23:00:00Z}
\CommentTok{#> 5     25 2013-12-19T22:00:00Z}
\CommentTok{#> 6      0 2013-12-17T22:00:00Z}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summarize}\NormalTok{(flights.df, }\DataTypeTok{mean_dep_delay =} \KeywordTok{mean}\NormalTok{(dep_delay, }\DataTypeTok{na.rm =}\NormalTok{T)) }\OperatorTok{%>%}\StringTok{ }\NormalTok{collect}
\CommentTok{#>   mean_dep_delay}
\CommentTok{#> 1       8.771247}
\CommentTok{#> 2      12.742945}
\CommentTok{#> 3      18.157297}
\CommentTok{#> 4       8.028106}
\end{Highlighting}
\end{Shaded}

\hypertarget{piping}{%
\subsection{Piping}\label{piping}}

One can chain \texttt{dplyr} verbs together like with a \texttt{data.frame}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c4 <-}\StringTok{ }\NormalTok{flights }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(month }\OperatorTok{==}\StringTok{ }\DecValTok{5}\NormalTok{, day }\OperatorTok{==}\StringTok{ }\DecValTok{17}\NormalTok{, carrier }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{'UA'}\NormalTok{, }\StringTok{'WN'}\NormalTok{, }\StringTok{'AA'}\NormalTok{, }\StringTok{'DL'}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(carrier, dep_delay, air_time, distance) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{air_time_hours =}\NormalTok{ air_time }\OperatorTok{/}\StringTok{ }\DecValTok{60}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\NormalTok{collect }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(carrier)}\CommentTok{# arrange should occur after `collect`}

\NormalTok{c4  }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#>   carrier dep_delay air_time distance air_time_hours}
\CommentTok{#> 1      AA        -7      142     1089       2.366667}
\CommentTok{#> 2      AA        -9      186     1389       3.100000}
\CommentTok{#> 3      AA        -6      143     1096       2.383333}
\CommentTok{#> 4      AA        -4      114      733       1.900000}
\CommentTok{#> 5      AA        -2      146     1085       2.433333}
\CommentTok{#> 6      AA        -7      119      733       1.983333}
\end{Highlighting}
\end{Shaded}

\hypertarget{list-of-supported-dplyr-verbs}{%
\subsection{\texorpdfstring{List of supported \texttt{dplyr} verbs}{List of supported dplyr verbs}}\label{list-of-supported-dplyr-verbs}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{select}
\NormalTok{rename}
\NormalTok{filter}
\NormalTok{arrange }\CommentTok{# within each chunk}
\NormalTok{group_by }\CommentTok{# within each chunk}
\NormalTok{summarise}\OperatorTok{/}\NormalTok{summarize }\CommentTok{# within each chunk}
\NormalTok{mutate}
\NormalTok{transmute}
\NormalTok{left_join}
\NormalTok{inner_join}
\NormalTok{full_join }\CommentTok{# careful. Performance!}
\NormalTok{semi_join}
\NormalTok{anit_join}
\end{Highlighting}
\end{Shaded}

\hypertarget{sharding-and-distribution-of-chunks}{%
\section{Sharding and distribution of chunks}\label{sharding-and-distribution-of-chunks}}

Like other distributed data manipulation frameworks \texttt{disk.frame} utilizes the \emph{sharding} concept to distribute the data into chunks. For example ``to shard by \texttt{cust\_id}'' means that all rows with the same \texttt{cust\_id} will be stored in the same chunk. This enables \texttt{group\_by} by \texttt{cust\_id} to produce the same results as non-chunked data.

The \texttt{by} variables that were used to shard the dataset are called the \texttt{shardkey}s. The \emph{sharding} is performed by computing a deterministic hash on the shard keys (the \texttt{by} variables) for each row. The hash function produces an integer between \texttt{1} and \texttt{n}, where \texttt{n} is the number of chunks.

\hypertarget{grouping}{%
\section{Grouping}\label{grouping}}

The \texttt{disk.frame} implements the \texttt{group\_by} operation with a significant caveat. In the \texttt{disk.frame} framework, group-by happen WITHIN each chunk and not ACROSS chunks. To achieve group by across chunk we need to put \textbf{all rows with the same group keys into the same file chunk}; this can be achieved with \texttt{hard\_group\_by}. However, the \texttt{hard\_group\_by} operation can be \textbf{VERY TIME CONSUMING} computationally and should be \textbf{avoided} if possible.

The \texttt{hard\_group\_by} operation is best illustrated with an example, suppose a \texttt{disk.frame} has three chunks

\begin{verbatim}
# chunk1 = 1.fst
#  id n
#1  a 1
#2  a 2
#3  b 3
#4  d 4

# chunk2 = 2.fst
#  id n
#1  a 4
#2  a 5
#3  b 6
#4  d 7

# chunk3 = 3.fst
#  id n
#1  a 4
#2  b 5
#3  c 6
\end{verbatim}

and notice that the \texttt{id} column contains 3 distinct values \texttt{"a"},\texttt{"b"}, and \texttt{"c"}. To perform \texttt{hard\_group\_by(df,\ by\ =\ id)} MAY give you the following \texttt{disk.frame} where all the \texttt{id}s with the same values end up in the same chunks.

\begin{verbatim}
# chunk1 = 1.fst
#  id n
#1  b 3
#2  b 6

# chunk2 = 2.fst
#  id n
#1  c 6
#2  d 4
#3  d 7

# chunk3 = 3.fst
#  id n
#1  a 1
#2  a 2
#3  a 4
#4  a 5
#5  a 4
\end{verbatim}

Also, notice that there is no guaranteed order for the distribution of the \texttt{id}s to the chunks. The order is random, but each chunk is likely to have a similar number of rows, provided that \texttt{id} does not follow a skewed distribution i.e.~where a few distinct values make up the majority of the rows.

Typically, \texttt{group\_by} is performed WITHIN each chunk. This is not an issue if the chunks have already been sharded on the \texttt{by} variables beforehand; however, if this is not the case then one may need a second stage aggregation to obtain the correct result, see \emph{Two-stage group by}.

By forcing the user to choose \texttt{group\_by} (within each chunk) and \texttt{hard\_group\_by} (across all chunks), this ensures that the user is conscious of the choice they are making. In \texttt{sparklyr} the equivalent of a \texttt{hard\_group\_by} is performed, which we should avoid, where possible, as it is time-consuming and expensive. Hence, \texttt{disk.frame} has chosen to explain the theory and allow the user to make a conscious choice when performing \texttt{(hard\_)group\_by}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{hard_group_by}\NormalTok{(carrier) }\OperatorTok{%>%}\StringTok{ }\CommentTok{# notice that hard_group_by needs to be set}
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{count =} \KeywordTok{n}\NormalTok{(), }\DataTypeTok{mean_dep_delay =} \KeywordTok{mean}\NormalTok{(dep_delay, }\DataTypeTok{na.rm=}\NormalTok{T)) }\OperatorTok{%>%}\StringTok{  }\CommentTok{# mean follows normal R rules}
\StringTok{  }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{arrange}\NormalTok{(carrier)}
\CommentTok{#> Appending disk.frames:}
\CommentTok{#> # A tibble: 16 x 3}
\CommentTok{#>    carrier count mean_dep_delay}
\CommentTok{#>    <chr>   <int>          <dbl>}
\CommentTok{#>  1 9E      18460          16.7 }
\CommentTok{#>  2 AA      32729           8.59}
\CommentTok{#>  3 AS        714           5.80}
\CommentTok{#>  4 B6      54635          13.0 }
\CommentTok{#>  5 DL      48110           9.26}
\CommentTok{#>  6 EV      54173          20.0 }
\CommentTok{#>  7 F9        685          20.2 }
\CommentTok{#>  8 FL       3260          18.7 }
\CommentTok{#>  9 HA        342           4.90}
\CommentTok{#> 10 MQ      26397          10.6 }
\CommentTok{#> 11 OO         32          12.6 }
\CommentTok{#> 12 UA      58665          12.1 }
\CommentTok{#> 13 US      20536           3.78}
\CommentTok{#> 14 VX       5162          12.9 }
\CommentTok{#> 15 WN      12275          17.7 }
\CommentTok{#> 16 YV        601          19.0}
\end{Highlighting}
\end{Shaded}

\hypertarget{two-stage-group-by}{%
\subsection{Two-stage group by}\label{two-stage-group-by}}

For most group-by tasks, the user can achieve the desired result WITHOUT using \texttt{hard\ =\ TRUE} by performing the group by in two stages. For example, suppose you aim to count the number of rows group by \texttt{carrier}, you can set \texttt{hard\ =\ F} to find the count within each chunk and then use a second group-by to summaries each chunk's results into the desired result. For example,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(carrier) }\OperatorTok{%>%}\StringTok{ }\CommentTok{# `group_by` aggregates within each chunk}
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{count =} \KeywordTok{n}\NormalTok{()) }\OperatorTok{%>%}\StringTok{  }\CommentTok{# mean follows normal R rules}
\StringTok{  }\NormalTok{collect }\OperatorTok{%>%}\StringTok{  }\CommentTok{# collect each individul chunks results and row-bind into a data.table}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(carrier) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{count =} \KeywordTok{sum}\NormalTok{(count)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{arrange}\NormalTok{(carrier)}
\CommentTok{#> # A tibble: 16 x 2}
\CommentTok{#>    carrier count}
\CommentTok{#>    <chr>   <int>}
\CommentTok{#>  1 9E      18460}
\CommentTok{#>  2 AA      32729}
\CommentTok{#>  3 AS        714}
\CommentTok{#>  4 B6      54635}
\CommentTok{#>  5 DL      48110}
\CommentTok{#>  6 EV      54173}
\CommentTok{#>  7 F9        685}
\CommentTok{#>  8 FL       3260}
\CommentTok{#>  9 HA        342}
\CommentTok{#> 10 MQ      26397}
\CommentTok{#> 11 OO         32}
\CommentTok{#> 12 UA      58665}
\CommentTok{#> 13 US      20536}
\CommentTok{#> 14 VX       5162}
\CommentTok{#> 15 WN      12275}
\CommentTok{#> 16 YV        601}
\end{Highlighting}
\end{Shaded}

Because this two-stage approach avoids the expensive \texttt{hard\ group\_by} operation, it is often significantly faster. However, it can be tedious to write; and this is a con of the \texttt{disk.frame} chunking mechanism.

\emph{Note}: this two-stage approach is similar to a map-reduce operation.

\hypertarget{restrict-input-columns-for-faster-processing}{%
\section{Restrict input columns for faster processing}\label{restrict-input-columns-for-faster-processing}}

One can restrict which input columns to load into memory for each chunk; this can significantly increase the speed of data processing. To restrict the input columns, use the \texttt{srckeep} function which only accepts column names as a string vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{srckeep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"carrier"}\NormalTok{,}\StringTok{"dep_delay"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{hard_group_by}\NormalTok{(carrier) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{count =} \KeywordTok{n}\NormalTok{(), }\DataTypeTok{mean_dep_delay =} \KeywordTok{mean}\NormalTok{(dep_delay, }\DataTypeTok{na.rm=}\NormalTok{T)) }\OperatorTok{%>%}\StringTok{  }\CommentTok{# mean follows normal R rules}
\StringTok{  }\NormalTok{collect}
\CommentTok{#> Appending disk.frames:}
\CommentTok{#> # A tibble: 16 x 3}
\CommentTok{#>    carrier count mean_dep_delay}
\CommentTok{#>    <chr>   <int>          <dbl>}
\CommentTok{#>  1 9E      18460          16.7 }
\CommentTok{#>  2 MQ      26397          10.6 }
\CommentTok{#>  3 UA      58665          12.1 }
\CommentTok{#>  4 US      20536           3.78}
\CommentTok{#>  5 AA      32729           8.59}
\CommentTok{#>  6 F9        685          20.2 }
\CommentTok{#>  7 HA        342           4.90}
\CommentTok{#>  8 VX       5162          12.9 }
\CommentTok{#>  9 WN      12275          17.7 }
\CommentTok{#> 10 B6      54635          13.0 }
\CommentTok{#> 11 FL       3260          18.7 }
\CommentTok{#> 12 OO         32          12.6 }
\CommentTok{#> 13 AS        714           5.80}
\CommentTok{#> 14 DL      48110           9.26}
\CommentTok{#> 15 EV      54173          20.0 }
\CommentTok{#> 16 YV        601          19.0}
\end{Highlighting}
\end{Shaded}

Input column restriction is one of the most critical efficiencies provided by \texttt{disk.frame}. Because the underlying format allows random access to columns (i.e.~retrieve only the columns used for processing), hence one can drastically reduce the amount of data loaded into RAM for processing by keeping only those columns that are directly used to produce the results.

\hypertarget{joins}{%
\section{Joins}\label{joins}}

\texttt{disk.frame} supports many dplyr joins including:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{left_join}
\NormalTok{inner_join}
\NormalTok{semi_join}
\NormalTok{inner_join}
\NormalTok{full_join }\CommentTok{# requires hard_group_by on both left and right}
\end{Highlighting}
\end{Shaded}

In all cases, the left dataset (\texttt{x}) must be a \texttt{disk.frame}, and the right dataset (\texttt{y}) can be either a \texttt{disk.frame} or a \texttt{data.frame}. If the right dataset is a \texttt{disk.frame} and the \texttt{shardkey}s are different between the two \texttt{disk.frame}s then two expensive \texttt{hard} \texttt{group\_by} operations are performed \emph{eagerly}, one on the left \texttt{disk.frame} and one on the right \texttt{disk.frame} to perform the joins correctly.

However, if the right dataset is a \texttt{data.frame} then \texttt{hard\_group\_by}s are only performed in the case of \texttt{full\_join}.

Note \texttt{disk.frame} does not support \texttt{right\_join} the user should use \texttt{left\_join} instead.

The below joins are performed \emph{lazily} because \texttt{airlines.dt} is a \texttt{data.table} not a \texttt{disk.frame}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# make airlines a data.table}
\NormalTok{airlines.dt <-}\StringTok{ }\KeywordTok{data.table}\NormalTok{(airlines)}
\CommentTok{# flights %>% left_join(airlines, by = "carrier") #}
\NormalTok{flights.df }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{left_join}\NormalTok{(airlines.dt, }\DataTypeTok{by =}\StringTok{"carrier"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\NormalTok{head}
\CommentTok{#>    year month day dep_time sched_dep_time dep_delay arr_time}
\CommentTok{#> 1: 2013     1   1      517            515         2      830}
\CommentTok{#> 2: 2013     1   1      533            529         4      850}
\CommentTok{#> 3: 2013     1   1      542            540         2      923}
\CommentTok{#> 4: 2013     1   1      544            545        -1     1004}
\CommentTok{#> 5: 2013     1   1      554            600        -6      812}
\CommentTok{#> 6: 2013     1   1      554            558        -4      740}
\CommentTok{#>    sched_arr_time arr_delay carrier flight tailnum origin dest air_time}
\CommentTok{#> 1:            819        11      UA   1545  N14228    EWR  IAH      227}
\CommentTok{#> 2:            830        20      UA   1714  N24211    LGA  IAH      227}
\CommentTok{#> 3:            850        33      AA   1141  N619AA    JFK  MIA      160}
\CommentTok{#> 4:           1022       -18      B6    725  N804JB    JFK  BQN      183}
\CommentTok{#> 5:            837       -25      DL    461  N668DN    LGA  ATL      116}
\CommentTok{#> 6:            728        12      UA   1696  N39463    EWR  ORD      150}
\CommentTok{#>    distance hour minute            time_hour                   name}
\CommentTok{#> 1:     1400    5     15 2013-01-01T10:00:00Z  United Air Lines Inc.}
\CommentTok{#> 2:     1416    5     29 2013-01-01T10:00:00Z  United Air Lines Inc.}
\CommentTok{#> 3:     1089    5     40 2013-01-01T10:00:00Z American Airlines Inc.}
\CommentTok{#> 4:     1576    5     45 2013-01-01T10:00:00Z        JetBlue Airways}
\CommentTok{#> 5:      762    6      0 2013-01-01T11:00:00Z   Delta Air Lines Inc.}
\CommentTok{#> 6:      719    5     58 2013-01-01T10:00:00Z  United Air Lines Inc.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{left_join}\NormalTok{(airlines.dt, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"carrier"}\NormalTok{, }\StringTok{"carrier"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\NormalTok{tail}
\CommentTok{#>    year month day dep_time sched_dep_time dep_delay arr_time}
\CommentTok{#> 1: 2013     9  30       NA           1842        NA       NA}
\CommentTok{#> 2: 2013     9  30       NA           1455        NA       NA}
\CommentTok{#> 3: 2013     9  30       NA           2200        NA       NA}
\CommentTok{#> 4: 2013     9  30       NA           1210        NA       NA}
\CommentTok{#> 5: 2013     9  30       NA           1159        NA       NA}
\CommentTok{#> 6: 2013     9  30       NA            840        NA       NA}
\CommentTok{#>    sched_arr_time arr_delay carrier flight tailnum origin dest air_time}
\CommentTok{#> 1:           2019        NA      EV   5274  N740EV    LGA  BNA       NA}
\CommentTok{#> 2:           1634        NA      9E   3393            JFK  DCA       NA}
\CommentTok{#> 3:           2312        NA      9E   3525            LGA  SYR       NA}
\CommentTok{#> 4:           1330        NA      MQ   3461  N535MQ    LGA  BNA       NA}
\CommentTok{#> 5:           1344        NA      MQ   3572  N511MQ    LGA  CLE       NA}
\CommentTok{#> 6:           1020        NA      MQ   3531  N839MQ    LGA  RDU       NA}
\CommentTok{#>    distance hour minute            time_hour                     name}
\CommentTok{#> 1:      764   18     42 2013-09-30T22:00:00Z ExpressJet Airlines Inc.}
\CommentTok{#> 2:      213   14     55 2013-09-30T18:00:00Z        Endeavor Air Inc.}
\CommentTok{#> 3:      198   22      0 2013-10-01T02:00:00Z        Endeavor Air Inc.}
\CommentTok{#> 4:      764   12     10 2013-09-30T16:00:00Z                Envoy Air}
\CommentTok{#> 5:      419   11     59 2013-09-30T15:00:00Z                Envoy Air}
\CommentTok{#> 6:      431    8     40 2013-09-30T12:00:00Z                Envoy Air}
\end{Highlighting}
\end{Shaded}

\hypertarget{window-functions-and-arbitrary-functions}{%
\section{Window functions and arbitrary functions}\label{window-functions-and-arbitrary-functions}}

\texttt{disk.frame} supports all \texttt{data.frame} operations, unlike Spark which can only perform those operations that Spark has implemented. Hence windowing functions like \texttt{rank} are supported out of the box.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Find the most and least delayed flight each day}
\NormalTok{bestworst <-}\StringTok{ }\NormalTok{flights.df }\OperatorTok{%>%}
\StringTok{   }\KeywordTok{srckeep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{,}\StringTok{"month"}\NormalTok{,}\StringTok{"day"}\NormalTok{, }\StringTok{"dep_delay"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{   }\KeywordTok{group_by}\NormalTok{(year, month, day) }\OperatorTok{%>%}
\StringTok{   }\KeywordTok{select}\NormalTok{(dep_delay) }\OperatorTok{%>%}
\StringTok{   }\KeywordTok{filter}\NormalTok{(dep_delay }\OperatorTok{==}\StringTok{ }\KeywordTok{min}\NormalTok{(dep_delay, }\DataTypeTok{na.rm =}\NormalTok{ T) }\OperatorTok{||}\StringTok{ }\NormalTok{dep_delay }\OperatorTok{==}\StringTok{ }\KeywordTok{max}\NormalTok{(dep_delay, }\DataTypeTok{na.rm =}\NormalTok{ T)) }\OperatorTok{%>%}
\StringTok{   }\NormalTok{collect}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
   

\NormalTok{bestworst }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#> # A tibble: 6 x 4}
\CommentTok{#> # Groups:   year, month, day [1]}
\CommentTok{#>    year month   day dep_delay}
\CommentTok{#>   <int> <int> <int>     <int>}
\CommentTok{#> 1  2013     1     1         2}
\CommentTok{#> 2  2013     1     1         4}
\CommentTok{#> 3  2013     1     1         2}
\CommentTok{#> 4  2013     1     1        -1}
\CommentTok{#> 5  2013     1     1        -6}
\CommentTok{#> 6  2013     1     1        -4}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Rank each flight within a daily}
\NormalTok{ranked <-}\StringTok{ }\NormalTok{flights.df }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{srckeep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{,}\StringTok{"month"}\NormalTok{,}\StringTok{"day"}\NormalTok{, }\StringTok{"dep_delay"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(year, month, day) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(dep_delay) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{rank =} \KeywordTok{rank}\NormalTok{(}\KeywordTok{desc}\NormalTok{(dep_delay))) }\OperatorTok{%>%}
\StringTok{  }\NormalTok{collect}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}
\CommentTok{#> Adding missing grouping variables: `year`, `month`, `day`}

\NormalTok{ranked }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#> # A tibble: 6 x 5}
\CommentTok{#> # Groups:   year, month, day [1]}
\CommentTok{#>    year month   day dep_delay  rank}
\CommentTok{#>   <int> <int> <int>     <int> <dbl>}
\CommentTok{#> 1  2013     1     1         2   313}
\CommentTok{#> 2  2013     1     1         4   276}
\CommentTok{#> 3  2013     1     1         2   313}
\CommentTok{#> 4  2013     1     1        -1   440}
\CommentTok{#> 5  2013     1     1        -6   742}
\CommentTok{#> 6  2013     1     1        -4   633}
\end{Highlighting}
\end{Shaded}

\hypertarget{arbitrary-by-chunk-processing}{%
\section{Arbitrary by-chunk processing}\label{arbitrary-by-chunk-processing}}

One can apply arbitrary transformations to each chunk of the \texttt{disk.frame} by using the \texttt{delayed} function which evaluates lazily or the \texttt{map.disk.frame(lazy\ =\ F)} function which evaluates eagerly. For example to return the number of rows in each chunk

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df1 <-}\StringTok{ }\KeywordTok{delayed}\NormalTok{(flights.df, }\OperatorTok{~}\KeywordTok{nrow}\NormalTok{(.x))}
\KeywordTok{collect_list}\NormalTok{(flights.df1) }\OperatorTok{%>%}\StringTok{ }\NormalTok{head }\CommentTok{# returns number of rows for each data.frame in a list}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 100000}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 100000}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 100000}
\CommentTok{#> }
\CommentTok{#> [[4]]}
\CommentTok{#> [1] 36776}
\end{Highlighting}
\end{Shaded}

and to do the same with \texttt{map.disk.frame}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map}\NormalTok{(flights.df, }\OperatorTok{~}\KeywordTok{nrow}\NormalTok{(.x), }\DataTypeTok{lazy =}\NormalTok{ F) }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 100000}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 100000}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 100000}
\CommentTok{#> }
\CommentTok{#> [[4]]}
\CommentTok{#> [1] 36776}
\end{Highlighting}
\end{Shaded}

The \texttt{map} function can also output the results to another disk.frame folder, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# return the first 10 rows of each chunk}
\NormalTok{flights.df2 <-}\StringTok{ }\KeywordTok{map}\NormalTok{(flights.df, }\OperatorTok{~}\NormalTok{.x[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{,], }\DataTypeTok{lazy =}\NormalTok{ F, }\DataTypeTok{outdir =} \KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp2"}\NormalTok{), }\DataTypeTok{overwrite =}\NormalTok{ T)}

\NormalTok{flights.df2 }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#>    year month day dep_time sched_dep_time dep_delay arr_time}
\CommentTok{#> 1: 2013     1   1      517            515         2      830}
\CommentTok{#> 2: 2013     1   1      533            529         4      850}
\CommentTok{#> 3: 2013     1   1      542            540         2      923}
\CommentTok{#> 4: 2013     1   1      544            545        -1     1004}
\CommentTok{#> 5: 2013     1   1      554            600        -6      812}
\CommentTok{#> 6: 2013     1   1      554            558        -4      740}
\CommentTok{#>    sched_arr_time arr_delay carrier flight tailnum origin dest air_time}
\CommentTok{#> 1:            819        11      UA   1545  N14228    EWR  IAH      227}
\CommentTok{#> 2:            830        20      UA   1714  N24211    LGA  IAH      227}
\CommentTok{#> 3:            850        33      AA   1141  N619AA    JFK  MIA      160}
\CommentTok{#> 4:           1022       -18      B6    725  N804JB    JFK  BQN      183}
\CommentTok{#> 5:            837       -25      DL    461  N668DN    LGA  ATL      116}
\CommentTok{#> 6:            728        12      UA   1696  N39463    EWR  ORD      150}
\CommentTok{#>    distance hour minute            time_hour}
\CommentTok{#> 1:     1400    5     15 2013-01-01T10:00:00Z}
\CommentTok{#> 2:     1416    5     29 2013-01-01T10:00:00Z}
\CommentTok{#> 3:     1089    5     40 2013-01-01T10:00:00Z}
\CommentTok{#> 4:     1576    5     45 2013-01-01T10:00:00Z}
\CommentTok{#> 5:      762    6      0 2013-01-01T11:00:00Z}
\CommentTok{#> 6:      719    5     58 2013-01-01T10:00:00Z}
\end{Highlighting}
\end{Shaded}

Notice \texttt{disk.frame} supports the \texttt{purrr} syntax for defining a function using \texttt{\textasciitilde{}}.

\hypertarget{sampling}{%
\section{Sampling}\label{sampling}}

In the \texttt{disk.frame} framework, sampling a proportion of rows within each chunk can be performed using \texttt{sample\_frac}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df }\OperatorTok{%>%}\StringTok{ }\KeywordTok{sample_frac}\NormalTok{(}\FloatTok{0.01}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\NormalTok{collect }\OperatorTok{%>%}\StringTok{ }\NormalTok{head}
\CommentTok{#>   year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time}
\CommentTok{#> 1 2013    12  13      859            900        -1     1226           1206}
\CommentTok{#> 2 2013    10  14     1910           1859        11     2123           2126}
\CommentTok{#> 3 2013    10   1     1719           1730       -11     1828           1847}
\CommentTok{#> 4 2013    12  17     2136           2129         7       34             10}
\CommentTok{#> 5 2013    12  10      736            737        -1      936            921}
\CommentTok{#> 6 2013    12   8     1326           1329        -3     1547           1538}
\CommentTok{#>   arr_delay carrier flight tailnum origin dest air_time distance hour}
\CommentTok{#> 1        20      B6   1701  N527JB    JFK  FLL      159     1069    9}
\CommentTok{#> 2        -3      FL    645  N956AT    LGA  ATL      106      762   18}
\CommentTok{#> 3       -19      B6   1516  N183JB    JFK  SYR       48      209   17}
\CommentTok{#> 4        24      B6    527  N593JB    EWR  MCO      142      937   21}
\CommentTok{#> 5        15      B6    885  N216JB    JFK  RDU       88      427    7}
\CommentTok{#> 6         9      EV   4687  N13566    EWR  CVG      108      569   13}
\CommentTok{#>   minute            time_hour}
\CommentTok{#> 1      0 2013-12-13T14:00:00Z}
\CommentTok{#> 2     59 2013-10-14T22:00:00Z}
\CommentTok{#> 3     30 2013-10-01T21:00:00Z}
\CommentTok{#> 4     29 2013-12-18T02:00:00Z}
\CommentTok{#> 5     37 2013-12-10T12:00:00Z}
\CommentTok{#> 6     29 2013-12-08T18:00:00Z}
\end{Highlighting}
\end{Shaded}

\hypertarget{writing-data}{%
\section{Writing Data}\label{writing-data}}

One can output a \texttt{disk.frame} by using the \texttt{write\_disk.frame} function. E.g.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write_disk.frame}\NormalTok{(flights.df, }\DataTypeTok{outdir=}\StringTok{"out"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

this will output a disk.frame to the folder ``out''

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fs}\OperatorTok{::}\KeywordTok{dir_delete}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.df"}\NormalTok{))}
\NormalTok{fs}\OperatorTok{::}\KeywordTok{dir_delete}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp2"}\NormalTok{))}
\NormalTok{fs}\OperatorTok{::}\KeywordTok{file_delete}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"tmp_flights.csv"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

There are a number of concepts and terminologies that are useful to understand in order to use \texttt{disk.frame} effectively.

\hypertarget{what-is-a-disk.frame-and-what-are-chunks}{%
\section{\texorpdfstring{What is a \texttt{disk.frame} and what are chunks?}{What is a disk.frame and what are chunks?}}\label{what-is-a-disk.frame-and-what-are-chunks}}

A \texttt{disk.frame} is nothing more a folder and in that folder there should be \href{https://www.fstpackage.org/}{\texttt{fst}} files named ``1.fst'', ``2.fst'', ``3.fst'' etc. Each of the ``.fst'' file is called a \emph{chunk}.

\hypertarget{workers-and-parallelism}{%
\section{Workers and parallelism}\label{workers-and-parallelism}}

Parallelism in \texttt{disk.frame} is achieved using the \href{https://cran.r-project.org/package=future}{\texttt{future} package}. When performing many tasks, \texttt{disk.frame} uses multiple workers, where each \emph{worker} is an R session, to perform the tasks in parallel. For example, suppose we wish to compute the number of rows for each chunk, we can clearly perform this simultaneously in parallel. The code to do that is

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# use only one column is fastest}
\NormalTok{df[,.N, keep =}\StringTok{ "first_col"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Say there are \texttt{n} chunks in \texttt{df}, and there are \texttt{m} workers. Then the first \texttt{m} chunks will run \texttt{chunk{[},.N{]}} simultaneously.

To see how many workers are at work, use

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# see how many workers are available for work}
\NormalTok{future}\OperatorTok{::}\KeywordTok{nbrOfWorkers}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Let's set-up \texttt{disk.frame}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(disk.frame)}

\CommentTok{# set up multiple}
\KeywordTok{setup_disk.frame}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

One of the most important tasks to perform before using the \texttt{disk.frame} package is to make some \texttt{disk.frame}s! There are a few functions to help you do that.

\hypertarget{convert-a-data.frame-to-disk.frame}{%
\section{\texorpdfstring{Convert a \texttt{data.frame} to \texttt{disk.frame}}{Convert a data.frame to disk.frame}}\label{convert-a-data.frame-to-disk.frame}}

Firstly there is \texttt{as.disk.frame()} which allows you to make a \texttt{disk.frame} from a \texttt{data.frame}, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df =}\StringTok{ }\KeywordTok{as.disk.frame}\NormalTok{(nycflights13}\OperatorTok{::}\NormalTok{flights)}
\end{Highlighting}
\end{Shaded}

will convert the \texttt{nycflights13::flights} \texttt{data.frame} to a \texttt{disk.frame} somewhere in \texttt{tempdir()}. To find out the location of the \texttt{disk.frame} use:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attr}\NormalTok{(flights.df, }\StringTok{"path"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can also specify a location to output the \texttt{disk.frame} to using \texttt{outdir}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flights.df =}\StringTok{ }\KeywordTok{as.disk.frame}\NormalTok{(nycflights13}\OperatorTok{::}\NormalTok{flights, }\DataTypeTok{outdir =} \StringTok{"some/path.df"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

it is recommended that you use \texttt{.df} as the extension for a \texttt{disk.frame}, however this is not an enforced requirement.

However, one of the reasons for \texttt{disk.frame} to exist is to handle larger-than-RAM files, hence \texttt{as.disk.frame} is not all that useful because it can only convert data that can fit into RAM. \texttt{disk.frame} comes with a couple more ways to create \texttt{disk.frame}.

\hypertarget{creating-disk.frame-from-csvs}{%
\section{\texorpdfstring{Creating \texttt{disk.frame} from CSVs}{Creating disk.frame from CSVs}}\label{creating-disk.frame-from-csvs}}

The function \texttt{csv\_to\_disk.frame} can convert CSV files to \texttt{disk.frame}. The most basic usage is

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{some.df =}\StringTok{ }\KeywordTok{csv_to_disk.frame}\NormalTok{(}\StringTok{"some/path.csv"}\NormalTok{, }\DataTypeTok{outdir =} \StringTok{"some.df"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

this will convert the CSV file \texttt{"some/path.csv"} to a \texttt{disk.frame}.

\hypertarget{multiple-csv-files}{%
\section{Multiple CSV files}\label{multiple-csv-files}}

However, sometimes we have multiple CSV files that you want to read in and row-bind into one large \texttt{disk.frame}. You can do so by supplying a vector of file paths e.g.~from the result of \texttt{list.files}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{some.df =}\StringTok{ }\KeywordTok{csv_to_disk.frame}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"some/path/file1.csv"}\NormalTok{, }\StringTok{"some/path/file2.csv"}\NormalTok{))}

\CommentTok{# or}
\NormalTok{some.df =}\StringTok{ }\KeywordTok{csv_to_disk.frame}\NormalTok{(}\KeywordTok{list.files}\NormalTok{(}\StringTok{"some/path"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{inputing-csv-files-chunk-wise}{%
\section{Inputing CSV files chunk-wise}\label{inputing-csv-files-chunk-wise}}

The \texttt{csv\_to\_disk.frame(path,\ ...)} function reads the file located at \texttt{path} in full into RAM but sometimes the CSV file may be too large to read in one go, as that would require loading the whole file into RAM. In that case, you can read the files chunk-by-chunk by using the \texttt{in\_chunk\_size} argument which controls how many rows you read in per chunk

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# to read in 1 million (=1e6) rows per chunk}
\KeywordTok{csv_to_disk.frame}\NormalTok{(path, }\DataTypeTok{in_chunk_size =} \FloatTok{1e6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{sharding}{%
\section{Sharding}\label{sharding}}

One of the most important aspects of \texttt{disk.frame} is sharding. One can shard a \texttt{disk.frame} at read time by using the \texttt{shardby}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{csv_to_disk.frame}\NormalTok{(path, }\DataTypeTok{shardby =} \StringTok{"id"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the above case, all rows with the same \texttt{id} values will end up in the same chunk.

\hypertarget{just-in-time-transformation}{%
\section{Just-in-time transformation}\label{just-in-time-transformation}}

Sometimes, one may wish to perform some transformation on the CSV before writing out to disk. One can use the \texttt{inmapfn} argument to do that. The \texttt{inmapfn} name comes from INput MAPping FuNction. The general usage pattern is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{csv_to_disk.frame}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"df.csv"}\NormalTok{), }\DataTypeTok{inmapfn =} \ControlFlowTok{function}\NormalTok{(chunk) \{}
  \KeywordTok{some_transformation}\NormalTok{(chunk)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

As a contrived example, suppose you wish to convert a string into date at read time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df =}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{date_str =} \KeywordTok{c}\NormalTok{(}\StringTok{"2019-01-02"}\NormalTok{, }\StringTok{"2019-01-02"}\NormalTok{))}

\CommentTok{# write the data.frame }
\KeywordTok{write.csv}\NormalTok{(df, }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"df.csv"}\NormalTok{))}


\CommentTok{# this would show that date_str is a string}
\KeywordTok{str}\NormalTok{(}\KeywordTok{collect}\NormalTok{(}\KeywordTok{csv_to_disk.frame}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"df.csv"}\NormalTok{)))}\OperatorTok{$}\NormalTok{date_str)}
\CommentTok{## chr [1:2] "2019-01-02" "2019-01-02"}

\CommentTok{# this would show that date_str is a string}
\NormalTok{df =}\StringTok{ }\KeywordTok{csv_to_disk.frame}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\StringTok{"df.csv"}\NormalTok{), }\DataTypeTok{inmapfn =} \ControlFlowTok{function}\NormalTok{(chunk) \{}
  \CommentTok{# convert to date_str to date format and store as "date"}
\NormalTok{  chunk[, date }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(date_str, }\StringTok{"%Y-%m-%d"}\NormalTok{)]}
\NormalTok{  chunk[, date_str}\OperatorTok{:}\ErrorTok{=}\OtherTok{NULL}\NormalTok{]}
\NormalTok{\})}

\KeywordTok{str}\NormalTok{(}\KeywordTok{collect}\NormalTok{(df)}\OperatorTok{$}\NormalTok{date)}
\CommentTok{## Date[1:2], format: "2019-01-02" "2019-01-02"}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-csvs-from-zip-files}{%
\section{Reading CSVs from zip files}\label{reading-csvs-from-zip-files}}

Often, CSV comes zipped in a zip files. You can use the \texttt{zip\_to\_disk.frame} to convert all CSVs within a zip file

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{zip_to_disk.frame}\NormalTok{(path_to_zip_file)}
\end{Highlighting}
\end{Shaded}

The arguments for \texttt{zip\_to\_disk.frame} are the same as \texttt{csv\_to\_disk.frame}'s.

\hypertarget{using-add_chunk}{%
\section{\texorpdfstring{Using \texttt{add\_chunk}}{Using add\_chunk}}\label{using-add_chunk}}

What if the method of converting to a \texttt{disk.frame} isn't implemented in \texttt{disk.frame} yet? One can use some lower level constructs provided by \texttt{disk.frame} to create \texttt{disk.frame}s. For example, the \texttt{add\_chunk} function can be used to add more chunks to a \texttt{disk.frame}, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a.df =}\StringTok{ }\KeywordTok{disk.frame}\NormalTok{() }\CommentTok{# create an empty disk.frame}
\KeywordTok{add_chunk}\NormalTok{(a.df, cars) }\CommentTok{# adds cars as chunk 1}
\KeywordTok{add_chunk}\NormalTok{(a.df, cars) }\CommentTok{# adds cars as chunk 2}
\end{Highlighting}
\end{Shaded}

Another example of using \texttt{add\_chunk} is via \texttt{readr}'s chunked read functions to create a delimited file reader

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{delimited_to_disk.frame <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(file, outdir, ...) \{}
\NormalTok{  res.df =}\StringTok{ }\KeywordTok{disk.frame}\NormalTok{(outdir, ...)}
\NormalTok{  readr}\OperatorTok{::}\KeywordTok{read_delim_chunked}\NormalTok{(file, }\DataTypeTok{callback =} \ControlFlowTok{function}\NormalTok{(chunk) \{}
    \KeywordTok{add_chunk}\NormalTok{(res.df, chunk)}
\NormalTok{  \}, ...)}
  
\NormalTok{  res.df}
\NormalTok{\}}

\KeywordTok{delimited_to_disk.frame}\NormalTok{(path, }\DataTypeTok{outdir =} \StringTok{"some.df"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The above code uses \texttt{readr}'s \texttt{read\_delim\_chunked} function to read \texttt{file} and call \texttt{add\_chunk}. The problem with this approach is that is it sequential in nature and hence is not able to take advantage of parallelism.

\hypertarget{exploiting-the-structure-of-a-disk.frame}{%
\section{Exploiting the structure of a disk.frame}\label{exploiting-the-structure-of-a-disk.frame}}

Of course, a \texttt{disk.frame} is just a folder with many \texttt{fst} files named as \texttt{1.fst}, \texttt{2.fst} etc. So one can simply create these \texttt{fst} files and ensure they have the same variable names and put them in a folder.

\hypertarget{disk.frame-supports-data.table-syntax}{%
\section{\texorpdfstring{\texttt{disk.frame} supports \texttt{data.table} syntax}{disk.frame supports data.table syntax}}\label{disk.frame-supports-data.table-syntax}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(disk.frame)}

\CommentTok{# set-up disk.frame to use multiple workers}
\ControlFlowTok{if}\NormalTok{(}\KeywordTok{interactive}\NormalTok{()) \{}
  \KeywordTok{setup_disk.frame}\NormalTok{()}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \KeywordTok{setup_disk.frame}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\CommentTok{#> The number of workers available for disk.frame is 2}


\KeywordTok{library}\NormalTok{(nycflights13)}

\CommentTok{# create a disk.frame}
\NormalTok{flights.df =}\StringTok{ }\KeywordTok{as.disk.frame}\NormalTok{(nycflights13}\OperatorTok{::}\NormalTok{flights, }\DataTypeTok{outdir =} \KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(),}\StringTok{"flights13"}\NormalTok{), }\DataTypeTok{overwrite =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the following example, I will use the \texttt{.N} from the \texttt{data.table} package to count the unique combinations \texttt{year} and \texttt{month} within each chunk.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(disk.frame)}

\NormalTok{flights.df =}\StringTok{ }\KeywordTok{disk.frame}\NormalTok{(}\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(),}\StringTok{"flights13"}\NormalTok{))}

\KeywordTok{names}\NormalTok{(flights.df)}
\CommentTok{#>  [1] "year"           "month"          "day"            "dep_time"      }
\CommentTok{#>  [5] "sched_dep_time" "dep_delay"      "arr_time"       "sched_arr_time"}
\CommentTok{#>  [9] "arr_delay"      "carrier"        "flight"         "tailnum"       }
\CommentTok{#> [13] "origin"         "dest"           "air_time"       "distance"      }
\CommentTok{#> [17] "hour"           "minute"         "time_hour"}

\NormalTok{flights.df[,.N, .(year, month), keep =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"month"}\NormalTok{)]}
\CommentTok{#>     year month     N}
\CommentTok{#>  1: 2013     1 27004}
\CommentTok{#>  2: 2013    10 28889}
\CommentTok{#>  3: 2013    11   237}
\CommentTok{#>  4: 2013    11 27031}
\CommentTok{#>  5: 2013    12 28135}
\CommentTok{#>  6: 2013     2   964}
\CommentTok{#>  7: 2013     2 23987}
\CommentTok{#>  8: 2013     3 28834}
\CommentTok{#>  9: 2013     4  3309}
\CommentTok{#> 10: 2013     4 25021}
\CommentTok{#> 11: 2013     5 28796}
\CommentTok{#> 12: 2013     6  2313}
\CommentTok{#> 13: 2013     6 25930}
\CommentTok{#> 14: 2013     7 29425}
\CommentTok{#> 15: 2013     8   775}
\CommentTok{#> 16: 2013     8 28552}
\CommentTok{#> 17: 2013     9 27574}
\end{Highlighting}
\end{Shaded}

All \texttt{data.table} syntax are supported. However, \texttt{disk.frame} adds the ability to load only those columns required for the analysis using the \texttt{keep\ =} option. In the above analysis, only the \texttt{year} and \texttt{month} variables are required and hence \texttt{keep\ =\ c("year",\ "month")} was used.

Alternatively, we can use the \texttt{srckeep} function to achieve the same, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{srckeep}\NormalTok{(flights.df, }\KeywordTok{c}\NormalTok{(}\StringTok{"year"}\NormalTok{, }\StringTok{"month"}\NormalTok{))[,.N, .(year, month)]}
\end{Highlighting}
\end{Shaded}

\hypertarget{external-variables-are-captured}{%
\subsection{External variables are captured}\label{external-variables-are-captured}}

\texttt{disk.frame} sends the computaion to background workers which are essentially distinct and separate R sessions. Typically, the variables that you have available in your current R session aren't visible in the other R sessions, but \texttt{disk.frame} uses the \texttt{future} package's variable detection abilities to figure out which variables are in use and then send them to the background workers so they have access to the variables as well. E.g.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y =}\StringTok{ }\DecValTok{42} 
\NormalTok{some_fn <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}


\NormalTok{flights.df[,}\KeywordTok{some_fn}\NormalTok{(y)]}
\CommentTok{#> [1] 42 42 42 42 42 42}
\end{Highlighting}
\end{Shaded}

In the above example, neither \texttt{some\_fn} nor \texttt{y} are defined in the background workers' environments, but \texttt{disk.frame} still manages to evaluate this code \texttt{flights.df{[},some\_fn(y){]}}.

\bibliography{book.bib,packages.bib}


\end{document}
